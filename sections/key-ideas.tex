\subsection{Key Ideas}
\label{ideas:sec}

From the observations, we propose {\tool} with the following ideas.

{\bf Key Idea 1 [Code Change Representation Learning with Graph
    Convolution Network (GCN)]}. From Observation 1, we could build an
ML model to untangle the commits by learning from the history of the
changed statements in the same commits for the same concerns. Instead
of deciding a deterministic clustering criterion on the concrete
artifacts such as PDGs, program slices, code changes, change
operations, or change graphs, we will {\em learn the vector
  representations (i.e., embeddings) for the code changes} while
taking into account the {\em dependencies}, the {\em contexts}, and
the {\em code clone relationships} among the changed statements. We
train an GCN model to learn the embeddings from the history of changed
code in the same commits for the same concerns. {\tool} then applies
agglomerative clustering on the embeddings to produce the clusters to
untangle the commit. We expect that agglomerative clustering is more
effective on the vector space than on the above concrete artifacts
because the embedddings capture richer information integrated from the
dependencies, contexts, and code clones.


{\bf Key Idea 2 [Explicit Context Representation as a Weight to
    Compute Vectors for Code Changes]}. As in Observation 2, the
contexts of the code changes can help distinguish their
purposes/concerns in the commits. We represent code changes and the
surrounding context of each change via the multi-version program
dependency graph, $\delta$-PDG~\cite{flexeme-fse20}. The context is
defined as the surrounding nodes of the node for a changed statement
in that graph. The GCN is used to model the statements and their
dependencies in the $\delta$-PDG and to learn the vector
representation of the context for a change. The context vector is then
used as a weight in learning the vector for the code change.

{\bf Key Idea 3 [Implicit Dependencies among Cloned Code]}. As in
Observation 3, the cloned code exhibits implicit dependencies with
regard to whether they can be changed in the same commits for the same
concerns/purposes. Thus, during the process of computing the embedding
for each change, we also integrate the code clones of the current
statement under consideration. The cloned code is integrated as a
feature for the GCN model to learn. Thus, the GCN model can learn the
embeddings of the code changes with the consideration of the cloned
code.
