\section{Updating Clusters via Code Clone Detection}

To enhance the accuracy of our clustering results, in this step, \tool uses the existing code clone technique \cite{svajlenko2017fast} to improve the clustering results. The clone detection results $CLONE$ include clone candidates with different sizes. Therefore, to help support the clustering results, we only pick candidates covering the changed statements. Also, to avoid duplication, we only choose the largest clone candidate that includes the same changed statements pair. For example, if code change statements $(CS_1, CS_2)$ and $(CS_3, CS_4)$ are clones, the $CLONE$ may include the clone candidate $C_1 = [(S_1, CS_1, CS_2), (S_2, CS_3, CS_4)]$ and $C_2= [(S_1, CS_1, CS_2, S_3), (S_2, CS_3, CS_4, S_4)]$ where $S_i$ are the unchanged statements. In this case, because the candidate $C_2$ is larger than $C_1$, and $C_2$ and $C_1$ contains the same code change statements, we only pick $C_2$ to avoid duplication. 

Next, for each code change candidate, we check the clustering results $CL_{pre}$ from the last step for all changed statements in the clone candidate and update the clustering results for all changed statements to the cluster that appeared for the most times. If there is a tie, we update the clustering results to the cluster with the smaller index. For example, in the clone candidate $C_2= [(S_1, CS_1, CS_2, S_3), (S_2, CS_3, CS_4, S_4)]$, if the clustering results show that the $CS_1, CS_2,$ and $CS_3$ are in $Concern_1$, and $CS_4$ is in $Concern_2$, we update the clustering result for changed statement $CS_4$ from $Concern_2$ to $Concern_1$. And if the clustering results show that the $CS_1, CS_3$ are in $Concern_1$, and $CS_2, CS_4$ are in $Concern_2$, we update the clustering results for changed statement $CS_2, CS_4$ from $Concern_2$ to $Concern_1$.



 

